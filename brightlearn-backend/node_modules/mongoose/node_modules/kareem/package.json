{
  "name": "kareem",
  "version": "2.6.3",
  "description": "Next-generation take on pre/post function hooks",
  "main": "index.js",
  "scripts": {
    "lint": "eslint .",
    "test": "mocha ./test/*",
    "test-coverage": "nyc --reporter lcov mocha ./test/*",
    "docs": "node ./docs.js"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/mongoosejs/kareem.git"
  },
  "devDependencies": {
    "acquit": "1.x",
    "acquit-ignore": "0.2.x",
    "eslint": "8.20.0",
    "mocha": "9.2.0",
    "nyc": "15.1.0"
  },
  "author": {
    "name": "Valeri Karpov",
    "email": "val@karpov.io"
  },
  "license": "Apache-2.0",
  "engines": {
    "node": ">=12.0.0"
  },
  "readme": "# kareem\n\n  [![Build Status](https://github.com/mongoosejs/kareem/actions/workflows/test.yml/badge.svg?branch=master)](https://github.com/mongoosejs/kareem/actions/workflows/test.yml)\n  <!--[![Coverage Status](https://img.shields.io/coveralls/vkarpov15/kareem.svg)](https://coveralls.io/r/vkarpov15/kareem)-->\n\nRe-imagined take on the [hooks](http://npmjs.org/package/hooks) module, meant to offer additional flexibility in allowing you to execute hooks whenever necessary, as opposed to simply wrapping a single function.\n\nNamed for the NBA's all-time leading scorer Kareem Abdul-Jabbar, known for his mastery of the [hook shot](http://en.wikipedia.org/wiki/Kareem_Abdul-Jabbar#Skyhook)\n\n<img src=\"http://upload.wikimedia.org/wikipedia/commons/0/00/Kareem-Abdul-Jabbar_Lipofsky.jpg\" width=\"220\">\n\n# API\n\n## pre hooks\n\nMuch like [hooks](https://npmjs.org/package/hooks), kareem lets you define\npre and post hooks: pre hooks are called before a given function executes.\nUnlike hooks, kareem stores hooks and other internal state in a separate\nobject, rather than relying on inheritance. Furthermore, kareem exposes\nan `execPre()` function that allows you to execute your pre hooks when\nappropriate, giving you more fine-grained control over your function hooks.\n\n\n#### It runs without any hooks specified\n\n```javascript\nhooks.execPre('cook', null, function() {\n  // ...\n});\n```\n\n#### It runs basic serial pre hooks\n\npre hook functions take one parameter, a \"done\" function that you execute\nwhen your pre hook is finished.\n\n\n```javascript\nvar count = 0;\n\nhooks.pre('cook', function(done) {\n  ++count;\n  done();\n});\n\nhooks.execPre('cook', null, function() {\n  assert.equal(1, count);\n});\n```\n\n#### It can run multipe pre hooks\n\n```javascript\nvar count1 = 0;\nvar count2 = 0;\n\nhooks.pre('cook', function(done) {\n  ++count1;\n  done();\n});\n\nhooks.pre('cook', function(done) {\n  ++count2;\n  done();\n});\n\nhooks.execPre('cook', null, function() {\n  assert.equal(1, count1);\n  assert.equal(1, count2);\n});\n```\n\n#### It can run fully synchronous pre hooks\n\nIf your pre hook function takes no parameters, its assumed to be\nfully synchronous.\n\n\n```javascript\nvar count1 = 0;\nvar count2 = 0;\n\nhooks.pre('cook', function() {\n  ++count1;\n});\n\nhooks.pre('cook', function() {\n  ++count2;\n});\n\nhooks.execPre('cook', null, function(error) {\n  assert.equal(null, error);\n  assert.equal(1, count1);\n  assert.equal(1, count2);\n});\n```\n\n#### It properly attaches context to pre hooks\n\nPre save hook functions are bound to the second parameter to `execPre()`\n\n\n```javascript\nhooks.pre('cook', function(done) {\n  this.bacon = 3;\n  done();\n});\n\nhooks.pre('cook', function(done) {\n  this.eggs = 4;\n  done();\n});\n\nvar obj = { bacon: 0, eggs: 0 };\n\n// In the pre hooks, `this` will refer to `obj`\nhooks.execPre('cook', obj, function(error) {\n  assert.equal(null, error);\n  assert.equal(3, obj.bacon);\n  assert.equal(4, obj.eggs);\n});\n```\n\n#### It can execute parallel (async) pre hooks\n\nLike the hooks module, you can declare \"async\" pre hooks - these take two\nparameters, the functions `next()` and `done()`. `next()` passes control to\nthe next pre hook, but the underlying function won't be called until all\nasync pre hooks have called `done()`.\n\n\n```javascript\nhooks.pre('cook', true, function(next, done) {\n  this.bacon = 3;\n  next();\n  setTimeout(function() {\n    done();\n  }, 5);\n});\n\nhooks.pre('cook', true, function(next, done) {\n  next();\n  var _this = this;\n  setTimeout(function() {\n    _this.eggs = 4;\n    done();\n  }, 10);\n});\n\nhooks.pre('cook', function(next) {\n  this.waffles = false;\n  next();\n});\n\nvar obj = { bacon: 0, eggs: 0 };\n\nhooks.execPre('cook', obj, function() {\n  assert.equal(3, obj.bacon);\n  assert.equal(4, obj.eggs);\n  assert.equal(false, obj.waffles);\n});\n```\n\n#### It supports returning a promise\n\nYou can also return a promise from your pre hooks instead of calling\n`next()`. When the returned promise resolves, kareem will kick off the\nnext middleware.\n\n\n```javascript\nhooks.pre('cook', function() {\n  return new Promise(resolve => {\n    setTimeout(() => {\n      this.bacon = 3;\n      resolve();\n    }, 100);\n  });\n});\n\nvar obj = { bacon: 0 };\n\nhooks.execPre('cook', obj, function() {\n  assert.equal(3, obj.bacon);\n});\n```\n\n## post hooks\n\nacquit:ignore:end\n\n#### It runs without any hooks specified\n\n```javascript\nhooks.execPost('cook', null, [1], function(error, eggs) {\n  assert.ifError(error);\n  assert.equal(1, eggs);\n  done();\n});\n```\n\n#### It executes with parameters passed in\n\n```javascript\nhooks.post('cook', function(eggs, bacon, callback) {\n  assert.equal(1, eggs);\n  assert.equal(2, bacon);\n  callback();\n});\n\nhooks.execPost('cook', null, [1, 2], function(error, eggs, bacon) {\n  assert.ifError(error);\n  assert.equal(1, eggs);\n  assert.equal(2, bacon);\n});\n```\n\n#### It can use synchronous post hooks\n\n```javascript\nvar execed = {};\n\nhooks.post('cook', function(eggs, bacon) {\n  execed.first = true;\n  assert.equal(1, eggs);\n  assert.equal(2, bacon);\n});\n\nhooks.post('cook', function(eggs, bacon, callback) {\n  execed.second = true;\n  assert.equal(1, eggs);\n  assert.equal(2, bacon);\n  callback();\n});\n\nhooks.execPost('cook', null, [1, 2], function(error, eggs, bacon) {\n  assert.ifError(error);\n  assert.equal(2, Object.keys(execed).length);\n  assert.ok(execed.first);\n  assert.ok(execed.second);\n  assert.equal(1, eggs);\n  assert.equal(2, bacon);\n});\n```\n\n#### It supports returning a promise\n\nYou can also return a promise from your post hooks instead of calling\n`next()`. When the returned promise resolves, kareem will kick off the\nnext middleware.\n\n\n```javascript\nhooks.post('cook', function(bacon) {\n  return new Promise(resolve => {\n    setTimeout(() => {\n      this.bacon = 3;\n      resolve();\n    }, 100);\n  });\n});\n\nvar obj = { bacon: 0 };\n\nhooks.execPost('cook', obj, obj, function() {\n  assert.equal(obj.bacon, 3);\n});\n```\n\n## wrap()\n\nacquit:ignore:end\n\n#### It wraps pre and post calls into one call\n\n```javascript\nhooks.pre('cook', true, function(next, done) {\n  this.bacon = 3;\n  next();\n  setTimeout(function() {\n    done();\n  }, 5);\n});\n\nhooks.pre('cook', true, function(next, done) {\n  next();\n  var _this = this;\n  setTimeout(function() {\n    _this.eggs = 4;\n    done();\n  }, 10);\n});\n\nhooks.pre('cook', function(next) {\n  this.waffles = false;\n  next();\n});\n\nhooks.post('cook', function(obj) {\n  obj.tofu = 'no';\n});\n\nvar obj = { bacon: 0, eggs: 0 };\n\nvar args = [obj];\nargs.push(function(error, result) {\n  assert.ifError(error);\n  assert.equal(null, error);\n  assert.equal(3, obj.bacon);\n  assert.equal(4, obj.eggs);\n  assert.equal(false, obj.waffles);\n  assert.equal('no', obj.tofu);\n\n  assert.equal(obj, result);\n});\n\nhooks.wrap(\n  'cook',\n  function(o, callback) {\n    assert.equal(3, obj.bacon);\n    assert.equal(4, obj.eggs);\n    assert.equal(false, obj.waffles);\n    assert.equal(undefined, obj.tofu);\n    callback(null, o);\n  },\n  obj,\n  args);\n```\n\n## createWrapper()\n\n#### It wraps wrap() into a callable function\n\n```javascript\nhooks.pre('cook', true, function(next, done) {\n  this.bacon = 3;\n  next();\n  setTimeout(function() {\n    done();\n  }, 5);\n});\n\nhooks.pre('cook', true, function(next, done) {\n  next();\n  var _this = this;\n  setTimeout(function() {\n    _this.eggs = 4;\n    done();\n  }, 10);\n});\n\nhooks.pre('cook', function(next) {\n  this.waffles = false;\n  next();\n});\n\nhooks.post('cook', function(obj) {\n  obj.tofu = 'no';\n});\n\nvar obj = { bacon: 0, eggs: 0 };\n\nvar cook = hooks.createWrapper(\n  'cook',\n  function(o, callback) {\n    assert.equal(3, obj.bacon);\n    assert.equal(4, obj.eggs);\n    assert.equal(false, obj.waffles);\n    assert.equal(undefined, obj.tofu);\n    callback(null, o);\n  },\n  obj);\n\ncook(obj, function(error, result) {\n  assert.ifError(error);\n  assert.equal(3, obj.bacon);\n  assert.equal(4, obj.eggs);\n  assert.equal(false, obj.waffles);\n  assert.equal('no', obj.tofu);\n\n  assert.equal(obj, result);\n});\n```\n\n## clone()\n\nacquit:ignore:end\n\n#### It clones a Kareem object\n\n```javascript\nvar k1 = new Kareem();\nk1.pre('cook', function() {});\nk1.post('cook', function() {});\n\nvar k2 = k1.clone();\nassert.deepEqual(Array.from(k2._pres.keys()), ['cook']);\nassert.deepEqual(Array.from(k2._posts.keys()), ['cook']);\n```\n\n## merge()\n\n#### It pulls hooks from another Kareem object\n\n```javascript\nvar k1 = new Kareem();\nvar test1 = function() {};\nk1.pre('cook', test1);\nk1.post('cook', function() {});\n\nvar k2 = new Kareem();\nvar test2 = function() {};\nk2.pre('cook', test2);\nvar k3 = k2.merge(k1);\nassert.equal(k3._pres.get('cook').length, 2);\nassert.equal(k3._pres.get('cook')[0].fn, test2);\nassert.equal(k3._pres.get('cook')[1].fn, test1);\nassert.equal(k3._posts.get('cook').length, 1);\n```\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/mongoosejs/kareem/issues"
  },
  "_id": "kareem@2.6.3",
  "dist": {
    "shasum": "63abf91f691e86061e5b12447a2ecd96706c31c5"
  },
  "_from": "kareem@2.6.3",
  "_resolved": "https://registry.npmjs.org/kareem/-/kareem-2.6.3.tgz"
}
