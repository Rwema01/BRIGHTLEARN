{
  "name": "path-to-regexp",
  "version": "8.2.0",
  "description": "Express style path to RegExp utility",
  "keywords": [
    "express",
    "regexp",
    "route",
    "routing"
  ],
  "repository": {
    "type": "git",
    "url": "https://github.com/pillarjs/path-to-regexp.git"
  },
  "license": "MIT",
  "exports": "./dist/index.js",
  "main": "dist/index.js",
  "typings": "dist/index.d.ts",
  "files": [
    "dist/"
  ],
  "scripts": {
    "bench": "vitest bench",
    "build": "ts-scripts build",
    "format": "ts-scripts format",
    "lint": "ts-scripts lint",
    "prepare": "ts-scripts install && npm run build",
    "size": "size-limit",
    "specs": "ts-scripts specs",
    "test": "ts-scripts test && npm run size"
  },
  "devDependencies": {
    "@borderless/ts-scripts": "^0.15.0",
    "@size-limit/preset-small-lib": "^11.1.2",
    "@types/node": "^22.7.2",
    "@types/semver": "^7.3.1",
    "@vitest/coverage-v8": "^2.1.1",
    "recheck": "^4.4.5",
    "size-limit": "^11.1.2",
    "typescript": "^5.5.3"
  },
  "engines": {
    "node": ">=16"
  },
  "publishConfig": {
    "access": "public"
  },
  "size-limit": [
    {
      "path": "dist/index.js",
      "limit": "2.2 kB"
    }
  ],
  "ts-scripts": {
    "dist": [
      "dist"
    ],
    "project": [
      "tsconfig.build.json"
    ]
  },
  "readme": "# Path-to-RegExp\n\n> Turn a path string such as `/user/:name` into a regular expression.\n\n[![NPM version][npm-image]][npm-url]\n[![NPM downloads][downloads-image]][downloads-url]\n[![Build status][build-image]][build-url]\n[![Build coverage][coverage-image]][coverage-url]\n[![License][license-image]][license-url]\n\n## Installation\n\n```\nnpm install path-to-regexp --save\n```\n\n## Usage\n\n```js\nconst {\n  match,\n  pathToRegexp,\n  compile,\n  parse,\n  stringify,\n} = require(\"path-to-regexp\");\n```\n\n### Parameters\n\nParameters match arbitrary strings in a path by matching up to the end of the segment, or up to any proceeding tokens. They are defined by prefixing a colon to the parameter name (`:foo`). Parameter names can use any valid JavaScript identifier, or be double quoted to use other characters (`:\"param-name\"`).\n\n```js\nconst fn = match(\"/:foo/:bar\");\n\nfn(\"/test/route\");\n//=> { path: '/test/route', params: { foo: 'test', bar: 'route' } }\n```\n\n### Wildcard\n\nWildcard parameters match one or more characters across multiple segments. They are defined the same way as regular parameters, but are prefixed with an asterisk (`*foo`).\n\n```js\nconst fn = match(\"/*splat\");\n\nfn(\"/bar/baz\");\n//=> { path: '/bar/baz', params: { splat: [ 'bar', 'baz' ] } }\n```\n\n### Optional\n\nBraces can be used to define parts of the path that are optional.\n\n```js\nconst fn = match(\"/users{/:id}/delete\");\n\nfn(\"/users/delete\");\n//=> { path: '/users/delete', params: {} }\n\nfn(\"/users/123/delete\");\n//=> { path: '/users/123/delete', params: { id: '123' } }\n```\n\n## Match\n\nThe `match` function returns a function for matching strings against a path:\n\n- **path** String or array of strings.\n- **options** _(optional)_ (Extends [pathToRegexp](#pathToRegexp) options)\n  - **decode** Function for decoding strings to params, or `false` to disable all processing. (default: `decodeURIComponent`)\n\n```js\nconst fn = match(\"/foo/:bar\");\n```\n\n**Please note:** `path-to-regexp` is intended for ordered data (e.g. paths, hosts). It can not handle arbitrarily ordered data (e.g. query strings, URL fragments, JSON, etc).\n\n## PathToRegexp\n\nThe `pathToRegexp` function returns a regular expression for matching strings against paths. It\n\n- **path** String or array of strings.\n- **options** _(optional)_ (See [parse](#parse) for more options)\n  - **sensitive** Regexp will be case sensitive. (default: `false`)\n  - **end** Validate the match reaches the end of the string. (default: `true`)\n  - **delimiter** The default delimiter for segments, e.g. `[^/]` for `:named` parameters. (default: `'/'`)\n  - **trailing** Allows optional trailing delimiter to match. (default: `true`)\n\n```js\nconst { regexp, keys } = pathToRegexp(\"/foo/:bar\");\n```\n\n## Compile (\"Reverse\" Path-To-RegExp)\n\nThe `compile` function will return a function for transforming parameters into a valid path:\n\n- **path** A string.\n- **options** (See [parse](#parse) for more options)\n  - **delimiter** The default delimiter for segments, e.g. `[^/]` for `:named` parameters. (default: `'/'`)\n  - **encode** Function for encoding input strings for output into the path, or `false` to disable entirely. (default: `encodeURIComponent`)\n\n```js\nconst toPath = compile(\"/user/:id\");\n\ntoPath({ id: \"name\" }); //=> \"/user/name\"\ntoPath({ id: \"cafÃ©\" }); //=> \"/user/caf%C3%A9\"\n\nconst toPathRepeated = compile(\"/*segment\");\n\ntoPathRepeated({ segment: [\"foo\"] }); //=> \"/foo\"\ntoPathRepeated({ segment: [\"a\", \"b\", \"c\"] }); //=> \"/a/b/c\"\n\n// When disabling `encode`, you need to make sure inputs are encoded correctly. No arrays are accepted.\nconst toPathRaw = compile(\"/user/:id\", { encode: false });\n\ntoPathRaw({ id: \"%3A%2F\" }); //=> \"/user/%3A%2F\"\n```\n\n## Stringify\n\nTransform `TokenData` (a sequence of tokens) back into a Path-to-RegExp string.\n\n- **data** A `TokenData` instance\n\n```js\nconst data = new TokenData([\n  { type: \"text\", value: \"/\" },\n  { type: \"param\", name: \"foo\" },\n]);\n\nconst path = stringify(data); //=> \"/:foo\"\n```\n\n## Developers\n\n- If you are rewriting paths with match and compile, consider using `encode: false` and `decode: false` to keep raw paths passed around.\n- To ensure matches work on paths containing characters usually encoded, such as emoji, consider using [encodeurl](https://github.com/pillarjs/encodeurl) for `encodePath`.\n\n### Parse\n\nThe `parse` function accepts a string and returns `TokenData`, the set of tokens and other metadata parsed from the input string. `TokenData` is can used with `match` and `compile`.\n\n- **path** A string.\n- **options** _(optional)_\n  - **encodePath** A function for encoding input strings. (default: `x => x`, recommended: [`encodeurl`](https://github.com/pillarjs/encodeurl))\n\n### Tokens\n\n`TokenData` is a sequence of tokens, currently of types `text`, `parameter`, `wildcard`, or `group`.\n\n### Custom path\n\nIn some applications, you may not be able to use the `path-to-regexp` syntax, but still want to use this library for `match` and `compile`. For example:\n\n```js\nimport { TokenData, match } from \"path-to-regexp\";\n\nconst tokens = [\n  { type: \"text\", value: \"/\" },\n  { type: \"parameter\", name: \"foo\" },\n];\nconst path = new TokenData(tokens);\nconst fn = match(path);\n\nfn(\"/test\"); //=> { path: '/test', index: 0, params: { foo: 'test' } }\n```\n\n## Errors\n\nAn effort has been made to ensure ambiguous paths from previous releases throw an error. This means you might be seeing an error when things worked before.\n\n### Unexpected `?` or `+`\n\nIn past releases, `?`, `*`, and `+` were used to denote optional or repeating parameters. As an alternative, try these:\n\n- For optional (`?`), use an empty segment in a group such as `/:file{.:ext}`.\n- For repeating (`+`), only wildcard matching is supported, such as `/*path`.\n- For optional repeating (`*`), use a group and a wildcard parameter such as `/files{/*path}`.\n\n### Unexpected `(`, `)`, `[`, `]`, etc.\n\nPrevious versions of Path-to-RegExp used these for RegExp features. This version no longer supports them so they've been reserved to avoid ambiguity. To use these characters literally, escape them with a backslash, e.g. `\"\\\\(\"`.\n\n### Missing parameter name\n\nParameter names must be provided after `:` or `*`, and they must be a valid JavaScript identifier. If you want an parameter name that isn't a JavaScript identifier, such as starting with a number, you can wrap the name in quotes like `:\"my-name\"`.\n\n### Unterminated quote\n\nParameter names can be wrapped in double quote characters, and this error means you forgot to close the quote character.\n\n### Express <= 4.x\n\nPath-To-RegExp breaks compatibility with Express <= `4.x` in the following ways:\n\n- The wildcard `*` must have a name, matching the behavior of parameters `:`.\n- The optional character `?` is no longer supported, use braces instead: `/:file{.:ext}`.\n- Regexp characters are not supported.\n- Some characters have been reserved to avoid confusion during upgrade (`()[]?+!`).\n- Parameter names now support valid JavaScript identifiers, or quoted like `:\"this\"`.\n\n## License\n\nMIT\n\n[npm-image]: https://img.shields.io/npm/v/path-to-regexp\n[npm-url]: https://npmjs.org/package/path-to-regexp\n[downloads-image]: https://img.shields.io/npm/dm/path-to-regexp\n[downloads-url]: https://npmjs.org/package/path-to-regexp\n[build-image]: https://img.shields.io/github/actions/workflow/status/pillarjs/path-to-regexp/ci.yml?branch=master\n[build-url]: https://github.com/pillarjs/path-to-regexp/actions/workflows/ci.yml?query=branch%3Amaster\n[coverage-image]: https://img.shields.io/codecov/c/gh/pillarjs/path-to-regexp\n[coverage-url]: https://codecov.io/gh/pillarjs/path-to-regexp\n[license-image]: http://img.shields.io/npm/l/path-to-regexp.svg?style=flat\n[license-url]: LICENSE.md\n",
  "readmeFilename": "Readme.md",
  "bugs": {
    "url": "https://github.com/pillarjs/path-to-regexp/issues"
  },
  "_id": "path-to-regexp@8.2.0",
  "dist": {
    "shasum": "403543a64fa56ea412f2af93536fad2fd87a28c1"
  },
  "_from": "path-to-regexp@^8.0.0",
  "_resolved": "https://registry.npmjs.org/path-to-regexp/-/path-to-regexp-8.2.0.tgz"
}
